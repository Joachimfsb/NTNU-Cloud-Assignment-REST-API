package models

import (
	"fmt"
	"time"
)

// NotificationDTO is a data transfer object that contains data transferred from the client to our server.
// To learn more about available events, please look at 'EVENT_*' in assignment2.util.events
type NotificationDTO struct {
	Url     string `json:"url"`   // Url is the url we will POST. This is provided by the client.
	Event   string `json:"event"` // Event is the type of event to be invoked.
	Country string `json:"country,omitempty"`
}

// NotificationDatabaseModel is the datastructure that we store in our database.
//
// The database will not perform any validity or integrity checks on our data structure. Please do so before committing
// it to the database.
type NotificationDatabaseModel struct {
	Id      string `json:"id,omitempty"`      // Id is the notification's unique identifier. For simplicity's sake it's called Id instead of uuid
	Url     string `json:"url"`               // Url is the url we will POST. This is provided by the client.
	Event   string `json:"event,omitempty"`   // Event is the type of event to be invoked.
	Country string `json:"country,omitempty"` // Country is used as filter to know what country a notification should be invoked on
}

// InvocationNotificationModel is send data to webhook subscribers.
type InvocationNotificationModel struct {
	Id      string    `json:"id"`
	Country string    `json:"country"`
	Event   string    `json:"event"`
	Time    time.Time `json:"time"`
}

// PopulateFromMap fills out the NotificationDatabaseModel with fields from a map of strings.
func (w *NotificationDatabaseModel) PopulateFromMap(data map[string]interface{}) {
	if val, ok := data["Id"].(string); ok {
		w.Id = val
	}
	if val, ok := data["Url"].(string); ok {
		w.Url = val
	}
	if val, ok := data["Event"].(string); ok {
		w.Event = val
	}
	if val, ok := data["Country"].(string); ok {
		w.Country = val
	}
}

// ValidateFromClient ensures that all required fields from the client are filled out.
func (w *NotificationDTO) ValidateFromClient() error {
	// Notes from Khai: This method should probably be refactored as the project
	// scales

	// URL and Event must be provided
	if w.Url != "" && w.Event != "" {
		return nil
	}

	// ID cannot be provided. This is generated by the server. We don't expose this fact to the client, so we simply
	// don't check for this.

	// If a field is missing, then append it to the error message
	errorMessage := "the fields [ "
	if w.Url == "" {
		// The URL may be invalid even if it is non-empty. We don't count for this.
		errorMessage += "url "
	}

	errorMessage += "] are required. Optional fields [ event country ] may be passed."

	return fmt.Errorf(errorMessage)
}
